"alembic init alembic" ->
This command creates our migration environment with a directory named "alembic" inside which has our versions
aka: migrations and it also creates an alembic.ini file in the current dir. 

-- EDITING THE ALEMBIC.INI FILE
Alembic looks in the curr dir (server in our case) for this file when any other cmd is run,
Note -> 
To indicate an alternative location the "--config" cmd can be used or the ALEMBIC_CONFIG env 
variable can be set. 

-- Escaping characters.
significant chars such as the "percentile signs" and the "@" must be escaped if we are usign
em in out .ini file -> we can do this using the urllib.parse.quoyte_plus function

e.g 
my_actual_password = "P@ssw%rd" - 
(contains both % and the @ sign which must be escaped if we want to use em in a URL)

output --
import urllib.parse
sqlalchemy_quoted_password = urllib.parse.quote_plus(my_actual_password)
sqlalchemy_quoted_password
'P%40ssw%25rd'
i.e, @ mapped to %40 and the % sign is mapped to %25

-- creating a migration script (after the environment is in place)
alembic revision -m "revision name"
eg alembic revision -m "create patient table"

The above cmd creates a python script with the f"{revision id}_{cmd name: create_patient_table}.py" as 
it's name inside the versions directory.
The file would contain the current revision id, the past revision id (the one we can rollback to, 
will be None for the ist revision.)

i.e 
revision: current revision id - 
down_revision: past revision's id

The file 'll also contain empty "upgrade" and "downgrade" functions.
Our job is to fill these functions with directives and logic that will apply a set of changes 
to our db

The "down_revision" directive --
This is how Alembic knows the correct order in which to apply migrations. When we create the next revision, 
the new fileâ€™s down_revision identifier would point to this one:

The you populate the upgrade and downgrade functions.
e.g --
We can use the op.create_table (imported as "from alembic import op") to create a table like this:
op.create_table(
    "table_name",
    sqlalchemy_columns as: sa.Column(sqlalchemy import as sa),
    // same usage for sqlalchemy columns class as we saw earlier.
)
i.e Our update that we wanna implement on our db.

-- Running our first migration
Now with the revision script in place, we can run the revision using the alembic upgrade command,
which will run upgrade ops from the current db version to any target version or simple the latest as "HEAD"

e.g alembic revision HEAD
output -- 
INFO  [alembic.context] Context class PostgresqlContext.
INFO  [alembic.context] Will assume transactional DDL.
INFO  [alembic.context] Running upgrade None (prev_revision) -> 1975ea83b712(new_revision)

-- The process above makes Alembic checks for a alembic_version table in our db and if not found,
will create it. Ot then looks for the current revision in the table 
(if any -> will be None at the ist revision) and then calculates the path from this revision to 
the revision requested, in this case: HEAD. It then invokes the upgrade method inside our revision file.

The downgrade method should also be populated, in the context that it's considered a good practice,
so in case we wanna rollback somewhere in the future, we can easily do while preserving actual
states we had along the way.


The alembic.ini file needs not to be modified except that the sqlalchemy db url must be accurately 
populated. alembic's ".ini" uses python's config parser library