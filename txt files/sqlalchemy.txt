Sqlalchemy is all about_
Classes as sql tables, module level constructs and python objects.

sqlalchemy.orm -> declarative_base | DeclarativeBase

Base = declarative_base()    |    class Base(DeclarativeBase)
and then all subclasses (sqlalchemy tables as python class contructs|models) inherit from this base class

- A mapped class like "User" below, typically refers to a single particular sql database table, 
the name of which is indicated by using the __tablename__ class-level attribute

when we declare a class that inherits from the DeclarativeBase class of sqlalchemy -
sqlalchemy does these:
creates and keeps a registry of all our tables | models | classes.
sets up the orm architecture | machinery that lets us devs use db rows as python objects



class User(Base):
    all tables must have a __tablename__ dunder property
    eg __tablename__ = "users"

    id: Mapped[int | str] = mapped_column(primary_key=True)
    addresses: Mapped[List["Address"]] = relationship(back_populates="user")


class Address(Base):
    __tablename__ = "address"

    user: Mapped["User"] = relationship(back_populates="addresses")



// Relationships in postgresql - sqlalchemy
addresses in class User is a column, actually a relationship 
implicitly pointing to the addresses table, here it means a user can have multiple addresses

it back_populates to user -
in address, u can see user as a relationship pointing to the user class | table 
back_populating to addresses

Distinction - 
In a relationship, use the name of the class, but for back_populates argument, use the name of the column 
to be used in the other table 


metadata - what Base.metadata.create_all(engine) actually does

Taken together, the combination of a string table name as well as a list of 
column declarations is known in SQLAlchemy as table metadata.

- sqlalchemy column parameters:
default: the default val for a col, set by python, then sent to the db
server_default: set by db itself, not py
on_update: we can do soemthing here like log the current time so that we know when this model was last
updated. automatically called when we update our model.


choosing the right column type.
TEXT vs STRING
NUMERIC vs INTEGER
JSON for lists, arrays etc


Engine

# The below snippet Create all tables
Base.metadata.create_all(engine)

This cmd above looks at all classes inheriting from Base and creates their tables
It's idempotent - safe to run multiple times, won't recreate existing tables


sql query commands:
get ->
args: col_name, primary_key val  
db.get(User, 1) -> get the user with id 1


cmds used at the end of our queries -> 
all() -> get all instances
first() -> get only the first one

Conditionals --
where -
db.query(table_name=User).where(User.email == {some_email})."either"(first() | all())

filter_by, filter

Multiple Conditions --
from sqlalchemy.orm import and_, or_


- - - - - -- - - - - - - - -- - - - - - -- - - - - - - - - - -- - 
Understanding SQLAlchemy Relationships --

Foreign Keys -
A foreign key is a column that references the primary key of another table. 
It's how we create connections between tables.

example -

class User(Base):
    __tablename__ = "users"

    id = Column(String, p_key=True)
    posts = relationship("Post", back_populates="user")



class Post(Base):
    __tablename__ = "posts"

    # FKEY: This is the db constraint - 
    # i.e you cannot insert any user's id which is not inside users table
    user_id = Column(String, ForeignKey("users.id))

    # creating an actual user inside a post Just for python convenience, not an actual column
    # so we could do -> post.user
    user = relationship("User", back_populates="posts")


ForeignKey(__tablename__.primary_key) # -> not class_name.primary_key
give the class_name to the relationship function, but __tablename__ to the 
back_populates parameter 
relationship("User", back_populates("users or something else."))


SQL Relationship types -

- One to many relationship  -  most common
doctor -> many schedules, schedule -> only a single doctors'

Intiution -> 
an author has many books but one book can belong to a single author
Delete an author, also delete his books, otherwise those books still point to that
author that doesn't exist.


Understanding cascade
example -> relationship(back_populates="", cascade="all, delete-orphan")

- cascade controls what happens to related objects when you modify them
- like what will happen to books which is an author's related object 
- when you modify an author, say delete one.

cascade - options
all, propogate all changes | ops -> save, update, delete etc

delete-orphan -> delete a book from author.books and it gets deleted from the db
# It is all about Understanding relationships
eg a book is an author's personal book, now he wants that it shouldn't be published and hard copies yet,
say are not out in the market, delete-orphan makes sense.
delete -> delete author, his books are deleted as well
delete a dr, no need to keep his schedules


- WITHOUT CASCADE
author = session.query(Author).first()
session.delete(author)
session.commit()  # ERROR! Books still reference this author


"all, delete-orphan" -> full parent-child relationship propogations
# most common in one to many rships 

"all" -> all changes except deletion
"save-update" -> only adds and updates # DEFAULT
None | False -> No cascade

lazy - # 3rd important relationship argument
Controls when related data is loaded
default -> "select"

- example
author = session.query(Author).first()
print(author.name)  # No extra query
print(author.books[0].title)  # NOW it queries: SELECT * FROM books WHERE author_id = ?

- example
books = relationship("Book", back_populates="author", lazy="joined")
author = session.query(Author).first() # (gets everything at once, books also)
print(author.books[0].title)  # No extra query - already loaded!

- Intiution -> load demanded data schedules of drs an initial query -> "joined"
- On demand data (data usually not needed instantly, when a user requests it)

- Lazy options - - -
"select" (default): Load related data when you access it (separate query)
"joined": Load everything at once with a JOIN (one big query)
"subquery": Load everything at once with a subquery
"selectin": Load related data with an IN query (best for collections)
"raise": Raise an error if you try to access unloaded data (prevents N+1 queries)
"dynamic": Return a query object instead of a list (for filtering large collections)

- Why LAZY ? # The (N + 1) query problem

- BAD: N+1 queries
authors = session.query(Author).all()  # 1 query
for author in authors:  # If 100 authors...
    print(author.books)  # 100 more queries! Total: 101 queries

- GOOD: Eager loading
from sqlalchemy.orm import joinedload
authors = session.query(Author).options(joinedload(Author.books)).all()  # 1 query
for author in authors:
    print(author.books)  # No extra queries!

- One to one relationship
needed when you want a record to point to exactly one record.
example -> user to user_profile

- code example
class User(Base):
    __tablename__ = 'users'
    
    # One-to-One: uselist=False makes this return a single object, not a list
    profile = relationship(
        "UserProfile",
        back_populates="user",
        uselist=False,  # This is the key!
        cascade="all, delete-orphan"
    )

class UserProfile(Base):
    __tablename__ = 'user_profiles'
    
    # The foreign key is on this side
    user_id = Column(Integer, ForeignKey('users.id'), unique=True, nullable=False)
    # unique=True enforces one-to-one at the database level
    
    user = relationship("User", back_populates="profile")


- Many to Many Relationships # Gets interesting!
is needed when both sides can have multiple related objects
- examples
doctor -> many clinics and vice versa
students -> courses and vice versa

How this works -> create an association | junction table
This is just a table not a model class.

junction = Table(
    "doctors_clinics",
    Base.metadata,
    Column("doctor_id", primary_key=True, ForeignKey("doctors.id")),
    Column("clinic_id", primary_key=True, ForeignKey("clinics.id"))
)

then,
- in Doctor class:
clinics = relationship(..., secondary=junction)

- in Clinic class:
doctors = relationship(..., secondary=junction)

- Database view

students table:
id | name
1  | Alice
2  | Bob

courses table:
id | title
1  | Python 101
2  | SQL Basics

student_courses table (junction):
student_id | course_id
1          | 1
1          | 2
2          | 1


- SQLAlchemy Type System
Three type systems to keep in mind here -
1. SQLAlchemy database types -  # sqlalchemy
2. python type hints - # typing
3. SQLAlchemy 2.0 Mapped Annotations - # sqlalchemy.orm

Since sqlalchemy 2.0, it supports python types resulting in better IDE help, code suggestions, actions etc ...
Result -> sqlalchemy db types with python types

- WHen to use which
Rule of Thumb:
Mapped[PythonType] tells Python/IDE what type the attribute will be at runtime
mapped_column(DatabaseType) tells the database how to store it

- For simple cases, sqlalchemy can infer the db type from python type hints,
problem example: name: Mapped[str] -> no length limit

- Primary Keys
use integers and the auto_increment param set to True for simple cases -> faster indexing as integers takes less space
uuids for complex cases