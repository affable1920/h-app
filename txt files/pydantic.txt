pydantic filed serialization

serialization takes place when converting a pydantic model to a python dict
or a json string i.e
-- model_dump or model_dump_json

many ways to serialize a pydantic field (a prop defined on a pydantic model)

1. Plain serializer

def ser_number(val: int):
    if not val:
        return or raises an error
    return val * 2

class PydanticModel(BaseModel):
    count: Annotated[int, PlainSerializer(ser_number)]

-> now say u created a model of the above class with count = 4 i.e: PydanticModel(count=4)

when you model dump this class,  count ll be 8


2. Wrap serializer
this gives more control, this function must be given an additional 2nd arg, 
the handler, doesn't matter if the handler is called or not

-- same ser_number function
  (val: int, handler: SerializeFunctionHandler)
     // same code returning val * 2
     or handler(val) * 2

class PydModel(BaseModel):
    count: Annotated[int, Wrapserializer(ser_number)]

model = PydModel(count=2)
model.model_dump() => count -> 4


3. the decorator ways
@field_serializer 

key benefits: apply the serializer on multiple fields of a model

class Model(...):
    ...props

    @field_serializer(name all fields u want to serialize)
    def serialize():
        your logic


if you want the serializer to apply to all fields, use * (includes fields from subclasses)

By default, the decorator will ensure the provided field name(s) are defined on the model. 
If you want to disable this check during class creation, you can do so by passing 
False to the check_fields argument. 

This is useful when the field serializer is defined on a base class, 
and the field is expected to exist on subclasses.